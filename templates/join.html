{% extends "base.html" %}
{% block content %}
<div class="card bg-secondary bg-opacity-10 border-0 shadow-lg">
  <div class="card-body">
    <h3 class="fw-bold mb-4">Join a Room</h3>
    <form id="joinForm" class="row g-2 mb-3">
      <div class="col-md-4">
        <input id="roomName" placeholder="Room ID" class="form-control" required>
      </div>
      <div class="col-md-5">
        <input type="file" id="videoFile" class="form-control" accept="video/*" required>
      </div>
      <div class="col-md-3 d-grid">
        <button class="btn btn-success">Join</button>
      </div>
    </form>
    <p id="status" class="text-muted"></p>

    <div id="playerWrap" class="mt-4" style="display:none;">
      <div class="d-flex justify-content-between align-items-center mb-2">
        <div class="fw-semibold">Room ID: <span id="room-id-display" class="text-success"></span></div>
        <button id="copyRoom" class="btn btn-sm btn-outline-light">Copy</button>
      </div>

      <video id="videoPlayer" controls class="w-100 rounded shadow-sm mb-2"></video>

      <div class="d-flex align-items-center gap-2 mb-3">
        <button class="btn btn-outline-success" onclick="document.getElementById('videoPlayer').play()">▶ Play</button>
        <button class="btn btn-outline-danger" onclick="document.getElementById('videoPlayer').pause()">⏸ Pause</button>
        <span id="time" class="ms-auto small text-muted">00:00</span>
      </div>

      <div class="row g-3">
        <!-- Video Chat -->
        <div class="col-md-6">
          <div class="p-3 bg-dark rounded shadow-sm h-100">
            <h5 class="mb-3">Video Chat</h5>
            <video id="localVideo" autoplay playsinline muted class="w-100 mb-2 rounded bg-black"></video>
            <video id="remoteVideo" autoplay playsinline class="w-100 rounded bg-black"></video>
            <div class="d-flex gap-2 mt-2">
              <button id="toggleCam" class="btn btn-sm btn-outline-light">Toggle Cam</button>
              <button id="toggleMic" class="btn btn-sm btn-outline-light">Mute</button>
            </div>
          </div>
        </div>
        <!-- Chat -->
        <div class="col-md-6">
          <div class="p-3 bg-dark rounded shadow-sm h-100 d-flex flex-column">
            <h5 class="mb-3">Chat</h5>
            <div id="chatBox" class="flex-grow-1 bg-black rounded p-2 overflow-auto mb-2" style="height:200px;"></div>
            <div class="input-group">
              <input id="chatInput" class="form-control" placeholder="Message...">
              <button id="sendChat" class="btn btn-success">Send</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* JOIN page JS
   Very similar to create but joiner waits for ready_for_call and then negotiates
*/
const socket = io();
let currentRoomID = null;
let localStream = null;
let peerConnection = null;
let isCamOn = true;
let isMicOn = true;
const STUN_CONFIG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

async function calculateHash(file) {
  const buffer = await file.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2,'0')).join('');
}

document.getElementById('joinForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const file = document.getElementById('videoFile').files[0];
  const roomName = document.getElementById('roomName').value.trim();
  if (!file || !roomName) return;
  document.getElementById('status').textContent = 'Checking file...';
  const hash = await calculateHash(file);
  socket.emit('join_room', { room_id: roomName, video_hash: hash });

  const video = document.getElementById('videoPlayer');
  video.src = URL.createObjectURL(file);
  currentRoomID = roomName;
});

socket.on('sync_state', (state) => {
  const video = document.getElementById('videoPlayer');
  video.isRemoteUpdate = true;
  if (Math.abs(video.currentTime - state.time) > 0.3) {
    video.currentTime = state.time;
  }
  if (state.paused) video.pause(); else video.play().catch(()=>{});
  setTimeout(()=>video.isRemoteUpdate = false, 200);

  // show UI
  document.getElementById('joinForm').style.display = 'none';
  document.getElementById('playerWrap').style.display = 'block';
  document.getElementById('room-id-display').textContent = currentRoomID;
  document.getElementById('status').textContent = 'Connected';
});

// when both ready, start camera & negotiation (joiner will createOffer OR wait for host depending on logic)
// we will start camera and createOffer as the "initiator=false" -> actually we wait for ready_for_call and then createOffer from host
socket.on('ready_for_call', async () => {
  // joiner starts camera & waits for offer or acts as answerer
  await startCamera();
  // create peer connection but wait for offer; handler below will answer offer
  await prepareCall(false);
});

socket.on('offer', async (data)=>{
  // this handler will be registered inside prepareCall
});
socket.on('answer', async (data)=>{
  // handled in prepareCall registration
});
socket.on('ice_candidate', async (data)=>{
  // handled
});

socket.on('error', (d)=>{ document.getElementById('status').textContent = '❌ ' + d.message; });

// chat
document.getElementById('sendChat').addEventListener('click', ()=>{
  const msg = document.getElementById('chatInput').value.trim();
  if (!msg || !currentRoomID) return;
  socket.emit('chat_message', { room_id: currentRoomID, message: msg });
  document.getElementById('chatInput').value = '';
});
socket.on('chat_message', (d)=>{
  const box = document.getElementById('chatBox');
  const el = document.createElement('div');
  el.className = 'chat-line';
  el.textContent = (d.sender === undefined ? 'Server' : (d.sender === socket.id ? 'You' : 'Peer')) + ': ' + d.message;
  box.appendChild(el);
  box.scrollTop = box.scrollHeight;
});

// copy
document.getElementById('copyRoom').addEventListener('click', ()=>{
  navigator.clipboard.writeText(currentRoomID).then(()=>{ alert('Room ID copied'); });
});

// Video element events (guest)
const videoEl = document.getElementById('videoPlayer');
videoEl.addEventListener('play', function(){
  if (!this.isRemoteUpdate && currentRoomID) {
    socket.emit('control', { room_id: currentRoomID, action: 'play', time: this.currentTime });
  }
});
videoEl.addEventListener('pause', function(){
  if (!this.isRemoteUpdate && currentRoomID) {
    socket.emit('control', { room_id: currentRoomID, action: 'pause', time: this.currentTime });
  }
});
videoEl.addEventListener('seeked', function(){
  if (!this.isRemoteUpdate && currentRoomID) {
    socket.emit('control', { room_id: currentRoomID, action: 'seek', time: this.currentTime });
  }
});
videoEl.addEventListener('timeupdate', function(){
  document.getElementById('time').textContent = formatTime(this.currentTime);
});

// WebRTC for joiner
async function startCamera() {
  if (localStream) return;
  localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
  document.getElementById('localVideo').srcObject = localStream;
}

async function prepareCall(isInitiator) {
  peerConnection = new RTCPeerConnection(STUN_CONFIG);
  localStream.getTracks().forEach(t => peerConnection.addTrack(t, localStream));
  peerConnection.ontrack = (ev) => {
    document.getElementById('remoteVideo').srcObject = ev.streams[0];
  };
  peerConnection.onicecandidate = (ev) => {
    if (ev.candidate && currentRoomID) {
      socket.emit('ice_candidate', { room_id: currentRoomID, candidate: ev.candidate });
    }
  };

  socket.on('offer', async (data)=>{
    if (data.room_id !== currentRoomID) return;
    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    socket.emit('answer', { room_id: currentRoomID, answer });
  });

  socket.on('answer', async (data)=>{
    if (data.room_id !== currentRoomID) return;
    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
  });

  socket.on('ice_candidate', async (data)=>{
    if (data.room_id !== currentRoomID) return;
    try { await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate)); } catch(e){ console.warn(e); }
  });

  // joiner doesn't initiate offer; host will. (we're prepared for offer -> answer)
}

// toggles
document.getElementById('toggleCam').addEventListener('click', ()=>{
  if (!localStream) return;
  isCamOn = !isCamOn;
  localStream.getVideoTracks().forEach(t => t.enabled = isCamOn);
  document.getElementById('toggleCam').textContent = isCamOn ? 'Turn Cam Off' : 'Turn Cam On';
});
document.getElementById('toggleMic').addEventListener('click', ()=>{
  if (!localStream) return;
  isMicOn = !isMicOn;
  localStream.getAudioTracks().forEach(t => t.enabled = isMicOn);
  document.getElementById('toggleMic').textContent = isMicOn ? 'Mute' : 'Unmute';
});

function formatTime(s){ const mm=Math.floor(s/60), ss=Math.floor(s%60); return `${mm.toString().padStart(2,'0')}:${ss.toString().padStart(2,'0')}`; }
</script>
{% endblock %}
